/*
 * GOLDEN-API
 * Trazadera Golden API
 *
 * OpenAPI spec version: 15
 * Contact: support@trazadera.com 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.trazadera.golden.restclient.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.trazadera.golden.restclient.model.Column;
import com.trazadera.golden.restclient.model.Dependency;
import com.trazadera.golden.restclient.model.Resource;
import com.trazadera.golden.restclient.model.Validation;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.threeten.bp.OffsetDateTime;
/**
 * A dataset represents the data format of a JSON record. Usually, a typed record defines the columns (plain or nested) of the JSON structure. There are other data types (eg. generic JSON) that allow for free formats.
 */
@Schema(description = "A dataset represents the data format of a JSON record. Usually, a typed record defines the columns (plain or nested) of the JSON structure. There are other data types (eg. generic JSON) that allow for free formats.")

public class Dataset extends Resource implements OneOfResourceExchangeDtoResourcesItems, OneOfResourceListResponseDtoResourcesItems, OneOfResourceResponseDtoResource {
  /**
   * Data type.
   */
  @JsonAdapter(DataTypeEnum.Adapter.class)
  public enum DataTypeEnum {
    @SerializedName("RECORD (Record (typed JSON))")
    RECORD_RECORD_TYPED_JSON_("RECORD (Record (typed JSON))"),
    @SerializedName("JSON (JSON (generic))")
    JSON_JSON_GENERIC_("JSON (JSON (generic))"),
    @SerializedName("TEXT (Text (generic))")
    TEXT_TEXT_GENERIC_("TEXT (Text (generic))"),
    @SerializedName("BINARY (Binary (generic))")
    BINARY_BINARY_GENERIC_("BINARY (Binary (generic))"),
    @SerializedName("XML (XML (generic))")
    XML_XML_GENERIC_("XML (XML (generic))");

    private String value;

    DataTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static DataTypeEnum fromValue(String input) {
      for (DataTypeEnum b : DataTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<DataTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DataTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public DataTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return DataTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("dataType")
  private DataTypeEnum dataType = null;

  @SerializedName("columns")
  private List<Column> columns = new ArrayList<Column>();

  /**
   * Identity function type.
   */
  @JsonAdapter(IdentityTypeEnum.Adapter.class)
  public enum IdentityTypeEnum {
    @SerializedName("DEFAULT (Default (unique object identifier))")
    DEFAULT_DEFAULT_UNIQUE_OBJECT_IDENTIFIER_("DEFAULT (Default (unique object identifier))"),
    @SerializedName("COLUMN (Use columns as identifier)")
    COLUMN_USE_COLUMNS_AS_IDENTIFIER_("COLUMN (Use columns as identifier)"),
    @SerializedName("SCRIPT (Custom script)")
    SCRIPT_CUSTOM_SCRIPT_("SCRIPT (Custom script)");

    private String value;

    IdentityTypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static IdentityTypeEnum fromValue(String input) {
      for (IdentityTypeEnum b : IdentityTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<IdentityTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IdentityTypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public IdentityTypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return IdentityTypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("identityType")
  private IdentityTypeEnum identityType = null;

  @SerializedName("identityScript")
  private String identityScript = null;

  @SerializedName("merger")
  private String merger = null;

  public Dataset dataType(DataTypeEnum dataType) {
    this.dataType = dataType;
    return this;
  }

   /**
   * Data type.
   * @return dataType
  **/
  @Schema(description = "Data type.")
  public DataTypeEnum getDataType() {
    return dataType;
  }

  public void setDataType(DataTypeEnum dataType) {
    this.dataType = dataType;
  }

  public Dataset columns(List<Column> columns) {
    this.columns = columns;
    return this;
  }

  public Dataset addColumnsItem(Column columnsItem) {
    this.columns.add(columnsItem);
    return this;
  }

   /**
   * List of columns in this dataset.
   * @return columns
  **/
  @Schema(required = true, description = "List of columns in this dataset.")
  public List<Column> getColumns() {
    return columns;
  }

  public void setColumns(List<Column> columns) {
    this.columns = columns;
  }

  public Dataset identityType(IdentityTypeEnum identityType) {
    this.identityType = identityType;
    return this;
  }

   /**
   * Identity function type.
   * @return identityType
  **/
  @Schema(description = "Identity function type.")
  public IdentityTypeEnum getIdentityType() {
    return identityType;
  }

  public void setIdentityType(IdentityTypeEnum identityType) {
    this.identityType = identityType;
  }

  public Dataset identityScript(String identityScript) {
    this.identityScript = identityScript;
    return this;
  }

   /**
   * Identity function script.
   * @return identityScript
  **/
  @Schema(description = "Identity function script.")
  public String getIdentityScript() {
    return identityScript;
  }

  public void setIdentityScript(String identityScript) {
    this.identityScript = identityScript;
  }

  public Dataset merger(String merger) {
    this.merger = merger;
    return this;
  }

   /**
   * Optional merger. The default merger uses the identity.
   * @return merger
  **/
  @Schema(description = "Optional merger. The default merger uses the identity.")
  public String getMerger() {
    return merger;
  }

  public void setMerger(String merger) {
    this.merger = merger;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Dataset dataset = (Dataset) o;
    return Objects.equals(this.dataType, dataset.dataType) &&
        Objects.equals(this.columns, dataset.columns) &&
        Objects.equals(this.identityType, dataset.identityType) &&
        Objects.equals(this.identityScript, dataset.identityScript) &&
        Objects.equals(this.merger, dataset.merger) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataType, columns, identityType, identityScript, merger, super.hashCode());
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Dataset {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    dataType: ").append(toIndentedString(dataType)).append("\n");
    sb.append("    columns: ").append(toIndentedString(columns)).append("\n");
    sb.append("    identityType: ").append(toIndentedString(identityType)).append("\n");
    sb.append("    identityScript: ").append(toIndentedString(identityScript)).append("\n");
    sb.append("    merger: ").append(toIndentedString(merger)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
