/*
 * GOLDEN-API
 * Trazadera Golden API
 *
 * OpenAPI spec version: 16-SNAPSHOT
 * Contact: support@trazadera.com 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.trazadera.golden.restclient.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.trazadera.golden.restclient.model.ColumnUI;
import com.trazadera.golden.restclient.model.Option;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
/**
 * Column definition, including name, description, dataset, validation rules, error rules and formatting/parsing. Also some UI guidelines.
 */
@Schema(description = "Column definition, including name, description, dataset, validation rules, error rules and formatting/parsing. Also some UI guidelines.")

public class Column {
  /**
   * Column type
   */
  @JsonAdapter(TypeEnum.Adapter.class)
  public enum TypeEnum {
    @SerializedName("TOKEN")
    TOKEN("TOKEN"),
    @SerializedName("DATASET")
    DATASET("DATASET");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TypeEnum fromValue(String input) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TypeEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public TypeEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TypeEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("type")
  private TypeEnum type = TypeEnum.TOKEN;

  /**
   * A token represents both the type of data and its semantics.
   */
  @JsonAdapter(TokenEnum.Adapter.class)
  public enum TokenEnum {
    @SerializedName("COUNTRY_CODE")
    COUNTRY_CODE("COUNTRY_CODE"),
    @SerializedName("COUNTRY_NAME")
    COUNTRY_NAME("COUNTRY_NAME"),
    @SerializedName("LANGUAGE")
    LANGUAGE("LANGUAGE"),
    @SerializedName("PHONE_COUNTRY_CODE")
    PHONE_COUNTRY_CODE("PHONE_COUNTRY_CODE"),
    @SerializedName("PHONE_NUMBER")
    PHONE_NUMBER("PHONE_NUMBER"),
    @SerializedName("PHONE")
    PHONE("PHONE"),
    @SerializedName("NAME_PREFIX")
    NAME_PREFIX("NAME_PREFIX"),
    @SerializedName("NAME_FIRST")
    NAME_FIRST("NAME_FIRST"),
    @SerializedName("NAME_MIDDLE")
    NAME_MIDDLE("NAME_MIDDLE"),
    @SerializedName("NAME_LAST")
    NAME_LAST("NAME_LAST"),
    @SerializedName("NAME")
    NAME("NAME"),
    @SerializedName("ADDRESS_STREET_TYPE")
    ADDRESS_STREET_TYPE("ADDRESS_STREET_TYPE"),
    @SerializedName("ADDRESS_STREET_NAME")
    ADDRESS_STREET_NAME("ADDRESS_STREET_NAME"),
    @SerializedName("ADDRESS_NUMBER")
    ADDRESS_NUMBER("ADDRESS_NUMBER"),
    @SerializedName("ADDRESS_STREET")
    ADDRESS_STREET("ADDRESS_STREET"),
    @SerializedName("ADDRESS_CITY")
    ADDRESS_CITY("ADDRESS_CITY"),
    @SerializedName("ADDRESS_POSTCODE")
    ADDRESS_POSTCODE("ADDRESS_POSTCODE"),
    @SerializedName("ADDRESS_STATE")
    ADDRESS_STATE("ADDRESS_STATE"),
    @SerializedName("ADDRESS")
    ADDRESS("ADDRESS"),
    @SerializedName("ID")
    ID("ID"),
    @SerializedName("EMAIL")
    EMAIL("EMAIL"),
    @SerializedName("NUMBER")
    NUMBER("NUMBER"),
    @SerializedName("DATE")
    DATE("DATE"),
    @SerializedName("ENUM")
    ENUM("ENUM"),
    @SerializedName("URL")
    URL("URL"),
    @SerializedName("TEXT")
    TEXT("TEXT"),
    @SerializedName("TEXT_AS_IS")
    TEXT_AS_IS("TEXT_AS_IS"),
    @SerializedName("IGNORE")
    IGNORE("IGNORE");

    private String value;

    TokenEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static TokenEnum fromValue(String input) {
      for (TokenEnum b : TokenEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<TokenEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final TokenEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public TokenEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return TokenEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("token")
  private TokenEnum token = TokenEnum.TEXT;

  @SerializedName("dataset")
  private String dataset = null;

  @SerializedName("key")
  private String key = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("identity")
  private Boolean identity = false;

  @SerializedName("array")
  private Boolean array = false;

  @SerializedName("empty")
  private Boolean empty = true;

  /**
   * Error handling
   */
  @JsonAdapter(ErrorEnum.Adapter.class)
  public enum ErrorEnum {
    @SerializedName("CLEAR")
    CLEAR("CLEAR"),
    @SerializedName("REPLACE")
    REPLACE("REPLACE"),
    @SerializedName("FIX")
    FIX("FIX"),
    @SerializedName("IGNORE")
    IGNORE("IGNORE");

    private String value;

    ErrorEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ErrorEnum fromValue(String input) {
      for (ErrorEnum b : ErrorEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ErrorEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ErrorEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public ErrorEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ErrorEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("error")
  private ErrorEnum error = ErrorEnum.IGNORE;

  @SerializedName("errorReplacement")
  private String errorReplacement = null;

  /**
   * Validation type
   */
  @JsonAdapter(ValidationEnum.Adapter.class)
  public enum ValidationEnum {
    @SerializedName("NONE")
    NONE("NONE"),
    @SerializedName("DEFAULT")
    DEFAULT("DEFAULT"),
    @SerializedName("PARSER")
    PARSER("PARSER"),
    @SerializedName("REGEX")
    REGEX("REGEX"),
    @SerializedName("SCRIPT")
    SCRIPT("SCRIPT");

    private String value;

    ValidationEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static ValidationEnum fromValue(String input) {
      for (ValidationEnum b : ValidationEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<ValidationEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final ValidationEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public ValidationEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return ValidationEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("validation")
  private ValidationEnum validation = ValidationEnum.NONE;

  @SerializedName("source")
  private String source = null;

  @SerializedName("sourceLocale")
  private String sourceLocale = null;

  @SerializedName("regex")
  private String regex = null;

  @SerializedName("script")
  private String script = null;

  @SerializedName("enumerations")
  private List<Option> enumerations = null;

  @SerializedName("ui")
  private ColumnUI ui = null;

  public Column type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Column type
   * @return type
  **/
  @Schema(description = "Column type")
  public TypeEnum getType() {
    return type;
  }

  public void setType(TypeEnum type) {
    this.type = type;
  }

  public Column token(TokenEnum token) {
    this.token = token;
    return this;
  }

   /**
   * A token represents both the type of data and its semantics.
   * @return token
  **/
  @Schema(description = "A token represents both the type of data and its semantics.")
  public TokenEnum getToken() {
    return token;
  }

  public void setToken(TokenEnum token) {
    this.token = token;
  }

  public Column dataset(String dataset) {
    this.dataset = dataset;
    return this;
  }

   /**
   * Dataset identifier.
   * @return dataset
  **/
  @Schema(description = "Dataset identifier.")
  public String getDataset() {
    return dataset;
  }

  public void setDataset(String dataset) {
    this.dataset = dataset;
  }

  public Column key(String key) {
    this.key = key;
    return this;
  }

   /**
   * Column name
   * @return key
  **/
  @Schema(required = true, description = "Column name")
  public String getKey() {
    return key;
  }

  public void setKey(String key) {
    this.key = key;
  }

  public Column description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Column description
   * @return description
  **/
  @Schema(required = true, description = "Column description")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public Column identity(Boolean identity) {
    this.identity = identity;
    return this;
  }

   /**
   * Identity flag. Indicates if the column is to be used for generating identity.
   * @return identity
  **/
  @Schema(description = "Identity flag. Indicates if the column is to be used for generating identity.")
  public Boolean isIdentity() {
    return identity;
  }

  public void setIdentity(Boolean identity) {
    this.identity = identity;
  }

  public Column array(Boolean array) {
    this.array = array;
    return this;
  }

   /**
   * Array flag. Indicates if the column supports multiple values.
   * @return array
  **/
  @Schema(description = "Array flag. Indicates if the column supports multiple values.")
  public Boolean isArray() {
    return array;
  }

  public void setArray(Boolean array) {
    this.array = array;
  }

  public Column empty(Boolean empty) {
    this.empty = empty;
    return this;
  }

   /**
   * Empty flag. Indicates if the column can be empty.
   * @return empty
  **/
  @Schema(description = "Empty flag. Indicates if the column can be empty.")
  public Boolean isEmpty() {
    return empty;
  }

  public void setEmpty(Boolean empty) {
    this.empty = empty;
  }

  public Column error(ErrorEnum error) {
    this.error = error;
    return this;
  }

   /**
   * Error handling
   * @return error
  **/
  @Schema(description = "Error handling")
  public ErrorEnum getError() {
    return error;
  }

  public void setError(ErrorEnum error) {
    this.error = error;
  }

  public Column errorReplacement(String errorReplacement) {
    this.errorReplacement = errorReplacement;
    return this;
  }

   /**
   * Error replacement. Indicates what to replace when an error is found if error policy is to replace.
   * @return errorReplacement
  **/
  @Schema(description = "Error replacement. Indicates what to replace when an error is found if error policy is to replace.")
  public String getErrorReplacement() {
    return errorReplacement;
  }

  public void setErrorReplacement(String errorReplacement) {
    this.errorReplacement = errorReplacement;
  }

  public Column validation(ValidationEnum validation) {
    this.validation = validation;
    return this;
  }

   /**
   * Validation type
   * @return validation
  **/
  @Schema(description = "Validation type")
  public ValidationEnum getValidation() {
    return validation;
  }

  public void setValidation(ValidationEnum validation) {
    this.validation = validation;
  }

  public Column source(String source) {
    this.source = source;
    return this;
  }

   /**
   * Data format. Used for validating the format.
   * @return source
  **/
  @Schema(description = "Data format. Used for validating the format.")
  public String getSource() {
    return source;
  }

  public void setSource(String source) {
    this.source = source;
  }

  public Column sourceLocale(String sourceLocale) {
    this.sourceLocale = sourceLocale;
    return this;
  }

   /**
   * Data locale. Used for validating the localized format.
   * @return sourceLocale
  **/
  @Schema(description = "Data locale. Used for validating the localized format.")
  public String getSourceLocale() {
    return sourceLocale;
  }

  public void setSourceLocale(String sourceLocale) {
    this.sourceLocale = sourceLocale;
  }

  public Column regex(String regex) {
    this.regex = regex;
    return this;
  }

   /**
   * Regular expression. Used for validation.
   * @return regex
  **/
  @Schema(description = "Regular expression. Used for validation.")
  public String getRegex() {
    return regex;
  }

  public void setRegex(String regex) {
    this.regex = regex;
  }

  public Column script(String script) {
    this.script = script;
    return this;
  }

   /**
   * Groovy script. Used for validation.
   * @return script
  **/
  @Schema(description = "Groovy script. Used for validation.")
  public String getScript() {
    return script;
  }

  public void setScript(String script) {
    this.script = script;
  }

  public Column enumerations(List<Option> enumerations) {
    this.enumerations = enumerations;
    return this;
  }

  public Column addEnumerationsItem(Option enumerationsItem) {
    if (this.enumerations == null) {
      this.enumerations = new ArrayList<Option>();
    }
    this.enumerations.add(enumerationsItem);
    return this;
  }

   /**
   * Enumeration key-value list.
   * @return enumerations
  **/
  @Schema(description = "Enumeration key-value list.")
  public List<Option> getEnumerations() {
    return enumerations;
  }

  public void setEnumerations(List<Option> enumerations) {
    this.enumerations = enumerations;
  }

  public Column ui(ColumnUI ui) {
    this.ui = ui;
    return this;
  }

   /**
   * Get ui
   * @return ui
  **/
  @Schema(description = "")
  public ColumnUI getUi() {
    return ui;
  }

  public void setUi(ColumnUI ui) {
    this.ui = ui;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Column column = (Column) o;
    return Objects.equals(this.type, column.type) &&
        Objects.equals(this.token, column.token) &&
        Objects.equals(this.dataset, column.dataset) &&
        Objects.equals(this.key, column.key) &&
        Objects.equals(this.description, column.description) &&
        Objects.equals(this.identity, column.identity) &&
        Objects.equals(this.array, column.array) &&
        Objects.equals(this.empty, column.empty) &&
        Objects.equals(this.error, column.error) &&
        Objects.equals(this.errorReplacement, column.errorReplacement) &&
        Objects.equals(this.validation, column.validation) &&
        Objects.equals(this.source, column.source) &&
        Objects.equals(this.sourceLocale, column.sourceLocale) &&
        Objects.equals(this.regex, column.regex) &&
        Objects.equals(this.script, column.script) &&
        Objects.equals(this.enumerations, column.enumerations) &&
        Objects.equals(this.ui, column.ui);
  }

  @Override
  public int hashCode() {
    return Objects.hash(type, token, dataset, key, description, identity, array, empty, error, errorReplacement, validation, source, sourceLocale, regex, script, enumerations, ui);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Column {\n");
    
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    token: ").append(toIndentedString(token)).append("\n");
    sb.append("    dataset: ").append(toIndentedString(dataset)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    identity: ").append(toIndentedString(identity)).append("\n");
    sb.append("    array: ").append(toIndentedString(array)).append("\n");
    sb.append("    empty: ").append(toIndentedString(empty)).append("\n");
    sb.append("    error: ").append(toIndentedString(error)).append("\n");
    sb.append("    errorReplacement: ").append(toIndentedString(errorReplacement)).append("\n");
    sb.append("    validation: ").append(toIndentedString(validation)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    sourceLocale: ").append(toIndentedString(sourceLocale)).append("\n");
    sb.append("    regex: ").append(toIndentedString(regex)).append("\n");
    sb.append("    script: ").append(toIndentedString(script)).append("\n");
    sb.append("    enumerations: ").append(toIndentedString(enumerations)).append("\n");
    sb.append("    ui: ").append(toIndentedString(ui)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
